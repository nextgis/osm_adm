# -*- coding: utf-8 -*-

import re

# коды автономных округов, которые до сих пор являются субъектами, закодированные на втором уровне
SUBJ_AD = (
    '11100000', # Ненецкий
    '71100000', # Ханты-Мансийский
    '71140000', # Ямало-Ненецкий
)

# статусные части
# У1, У2, У3, НП, regexp, расшифровка, упрощенный статус
STATUS_SEARCH = (
 (0, 0, 0, 1, r'г\s+(.*)',    'город',                      'город'     ),
 (0, 0, 0, 1, r'пгт\s+(.*)',  'поселок городского типа',    'пгт'       ),
 (0, 0, 0, 1, r'рп\s+(.*)',   'рабочий поселок',            'поселок'   ),
 (0, 0, 0, 1, r'кп\s+(.*)',   'курортный поселок',          'поселок'   ),
 (0, 0, 0, 1, r'к\s+(.*)',    'кишлак',                     'кишлак'    ),
 (0, 0, 0, 1, r'пс\s+(.*)',   'поселковый совет',           'поселок'   ),
 (0, 0, 0, 1, r'смн\s(.*)',   'cмн',                        'сомон'     ),
 (0, 0, 0, 1, r'д\s+(.*)',    'деревня',                    'деревня'   ),
 (0, 0, 0, 1, r'с\s+(.*)',    'село',                       'село'      ),
 (0, 0, 0, 1, r'вл\s+(.*)',   'волость',                    'волость'   ),
 (0, 0, 0, 1, r'дп\s+(.*)',   'дачный поселковый совет',    'поселок'   ),
 (0, 0, 0, 1, r'п\s+(.*)',    'поселок сельского типа',     'село'      ),
 (0, 0, 0, 1, r'нп\s+(.*)',   'населенный пункт',           'нп'        ),
 (0, 0, 0, 1, r'сл\s+(.*)',   'слобода',                    'слобода'   ),
 (0, 0, 0, 1, r'ст\s+(.*)',   'станция',                    'ст'        ),
 
)

_STATUS_SEARCH = []

for itm in STATUS_SEARCH:
  n = itm[:4] + (re.compile(itm[4], re.UNICODE),) + itm[5:]
  _STATUS_SEARCH.append(n)

  #       'нп' => 'населенный пункт',
  #       'п.ст' => 'поселок при станции',
  #       'жд_ст' => 'железнодорожная станция',
  # 'ж/д' => 'населенный пункт',
  #       'с' => 'село',
  #       'м' => 'местечко',
  #       'д' => 'деревня',
  #       'сл' => 'слобода',
  #       'ст' => 'станция',
  #       'ст-ца' => 'станица',
  #       'х' => 'хутор',
  #       'у' => 'улус',
  #       'рзд' => 'разъезд',
  #       'клх' => 'колхоз',
  #       'им' => 'имени',
  #       'свх' => 'совхоз',
  #       'зим' => 'зимовье'
  #   ('')

def fill(start, to_len=8):
  while len(start) < to_len:
    start = start + '0'
  return start  

from sqlalchemy import Column as C, Unicode, ForeignKey, SmallInteger, Boolean, Enum
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class OkatoObj(Base):
  __tablename__ = 'okato'

  CLS_ENUM = (
    u'адм_район',                # районы субъекта
    u'город',                    # города
    u'пгт',                      # поселки городского типа
    u'город|пгт',
    u'гфз_1',                    # первый уровень деления ГФЗ: округа Москвы, районы Спб
    u'гфз_2',                    # второй уровень деления ГФЗ: районы Москвы, округа Спб
    u'нп',
    u'сельсовет',
    u'unknown',
    u'гор_район'                 # район города, или городского округа
  )
  
  code = C(Unicode(11), primary_key=True) # код ОКАТО
  raw  = C(Unicode(255))                  # строка из ОКАТО as-is

  is_group = C(Boolean())       # это группировка ?
  parent = C(Unicode(11))       # родитель с учетом группировок
  parent_obj = C(Unicode(11))   # родитель без учета группировок
  
  lvl  = C(SmallInteger())                     # уровень

  cls  = C(Unicode(10))
  # cls  = C(Enum(*CLS_ENUM, native_enum=False)) # класс

  is_settlement = C(Boolean())  # это населенный пункт 
  is_subject = C(Boolean())     # это субъект
  name = C(Unicode(100))        # имя без статусной части
  status = C(Unicode(100))      # статусная часть

  cl_class = None
  cl_level = None
  manager = None

  def parse(self, lookup=None):
    code = self.code
    raw  = self.raw
    self.manager = None

    # код заканчивается на n нулей
    zeroes = lambda n: self.code.endswith('0' * n)
      
    # все группировки заканчиваются на '/'
    self.is_group = raw[-1] == '/'

    p1 = int(code[2])    # признак 1 - разряд 3
    p2 = int(code[5])    # признак 2 - разряд 6
    v1 = int(code[3:5])  # разряды 4-5
    v2 = int(code[6:8])  # разряды 7-8

    level = None

    if self.is_group:
      if len(code) == 8:
        if zeroes(5):
          self.parent = fill(code[:2])
        if code.endswith(('00', '50')):
          self.parent = code[:5] + '000'
      if len(code) == 11:
        assert code[-3:] == '000', 'Ошибка в группировке'  
        self.parent = fill(code[:8])
        self.parent_obj = fill(code[:8])

    elif len(code) == 8 and not self.is_group:
      if zeroes(6):
        self.cl_level = 1
        self.parent     = None
        self.parent_obj = None
      elif zeroes(3):
        self.cl_level = 2
        self.parent = code[:3] + '00000'
        self.parent_obj = code[:2] + '000000'
        if p1 == 2:
          self.parent_obj = code[:2] + '000000'
          if v1 in range(1, 60):
            self.cl_class = 'адм_район'
            self.parent     = code[:3] + '00000'
          elif v1 in range(60, 100):
            self.cl_class = 'гфз_1'
            self.parent     = code[:3] + '60000'

        elif p1 == 4:
          # по описанию статуc должен зависеть от v1,
          # но на московской области это не работает,
          # поэтому город или пгт
          # self.cl_class = "город|пгт" 
          
          # попробуем посмотреть группировку верхнего уровня
          p_code = code[:3] + '00000'
          if lookup:
            parent_group = lookup(OkatoObj, OkatoObj.code == p_code.encode('utf-8'))
            pr = parent_group.raw

            if pr.startswith(u'Города'):
              self.cl_class = 'город'

            elif pr.startswith(u'Поселки городского типа'):
              self.cl_class = 'пгт'  
            
        elif p1 == 5:

          # это значения признака в классификаторе не описано,
          # на московской области вроде бы работает
          if   v1 in range(1, 60):
            self.cl_class = 'город'
          elif v1 in range(60, 100):
            self.cl_class = 'пгт'
            
      else:  
        self.cl_level = 3
        self.parent = code[:7] + '0'
        self.parent_obj = code[:5] + '000'
        if p2 == 3:
          self.cl_class = 'гор_район'
        elif p2 == 5:
          if v2 in range(1, 50):
              self.cl_class = 'город'
          elif v2 in range(50, 100):
            if v1 in range(60, 100):
              self.cl_class = 'гфз_2'  
            elif v1 in range(1, 60):   
              self.cl_class = 'пгт'
        elif p2 == 6:
          # в самарской области сюда попадают устраненные НП в Тольяти  
          self.cl_class = 'unknown'  
        elif p2 == 8:
          self.cl_class = 'сельсовет'  
    elif len(code) == 11 and not self.is_group:
      self.cl_level = 4
      self.cl_class = 'нп'
      self.parent = fill(code[:8], to_len=11)
      self.parent_obj = fill(code[:8])
    
    # на первом уровне все субъекты, на втором только то, что еще не успели упразднить
    self.is_subject = self.cl_level == 1 or (self.cl_level == 2 and code in SUBJ_AD)

    self.is_district = len(code) == 8 and code[2] == '2' and code[-3:] == '000' and code[3:5] <> '00'
    self.is_city = len(code) == 8 and code[2] == '4' and code[-3:] == '000' and code[3:5] <> '00'

    if self.cl_class in ('город', 'пгт', 'город|пгт'):
        self.is_settlement = True
        if self.cl_class in ('город'):
          self.name = raw
          self.status = self.cl_class
        elif self.cl_class in ('пгт'):
          self.name = raw  
          self.status = "поселок городского типа"  
    if len(code) == 11 and not self.is_group:
      # сельские НП  
      self.is_settlement = True

    self.lvl = self.cl_level
    self.cls = self.cl_class
    
    # определяем статус
    for ss in _STATUS_SEARCH:
      m = ss[4].match(raw)
      if m:
        self.name = m.group(1)
        self.status = ss[5]
        self.status_simple = ss[6]


metadata = Base.metadata

def reader(src, lookup=None):
  for l in src:
    i = l[:-1].decode('utf-8')
    obj = OkatoObj()
    (code, raw) = i.split("\t")
    obj.code = code
    obj.raw = raw
    obj.parse(lookup=lookup)
    yield obj
